
AVRASM ver. 2.2.6  C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm Sun Jun 04 19:36:31 2017

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.0.79\avrasm\inc\tn13adef.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(54): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\font.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(55): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\timer.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.0.79\avrasm\inc\tn13adef.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(54): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\font.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(55): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\timer.inc'
                                 
                                 ; at 9.6mhz, 10 cycles = 1us
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATtiny13A.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn13Adef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny13A
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny13A
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN13ADEF_INC_
                                 #define _TN13ADEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny13A
                                 #pragma AVRPART ADMIN PART_NAME ATtiny13A
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x90
                                 .equ	SIGNATURE_002	= 0x07
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2
                                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	GIMSK	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK0	= 0x39
                                 .equ	TIFR0	= 0x38
                                 .equ	SPMCSR	= 0x37
                                 .equ	OCR0A	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	TCCR0B	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OSCCAL	= 0x31
                                 .equ	BODCR	= 0x30
                                 .equ	TCCR0A	= 0x2f
                                 .equ	DWDR	= 0x2e
                                 .equ	OCR0B	= 0x29
                                 .equ	GTCCR	= 0x28
                                 .equ	CLKPR	= 0x26
                                 .equ	PRR	= 0x25
                                 .equ	WDTCR	= 0x21
                                 .equ	EEAR	= 0x1e
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PCMSK	= 0x15
                                 .equ	DIDR0	= 0x14
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	ADCSRB	= 0x03
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                                 
                                 ; DIDR0 - Digital Input Disable Register 0
                                 .equ	ADC1D	= 2	; ADC2 Digital input Disable
                                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                                 .equ	ADC2D	= 4	; ADC2 Digital input Disable
                                 .equ	ADC0D	= 5	; ADC0 Digital input Disable
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	AINBG	= ACBG	; For compatibility
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR0 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEAR - EEPROM Read/Write Access
                                 .equ	EEARL	= EEAR	; For compatibility
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access bit 5
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEPE	= EEWE	; For compatibility
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EEMPE	= EEMWE	; For compatibility
                                 .equ	EERIE	= 3	; EEProm Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; 
                                 .equ	EEPM1	= 5	; 
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Data Register, Port B
                                 .equ	PORTB0	= 0	; 
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; 
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; 
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; 
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; 
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; 
                                 .equ	PB5	= 5	; For compatibility
                                 
                                 ; DDRB - Data Direction Register, Port B
                                 .equ	DDB0	= 0	; 
                                 .equ	DDB1	= 1	; 
                                 .equ	DDB2	= 2	; 
                                 .equ	DDB3	= 3	; 
                                 .equ	DDB4	= 4	; 
                                 .equ	DDB5	= 5	; 
                                 
                                 ; PINB - Input Pins, Port B
                                 .equ	PINB0	= 0	; 
                                 .equ	PINB1	= 1	; 
                                 .equ	PINB2	= 2	; 
                                 .equ	PINB3	= 3	; 
                                 .equ	PINB4	= 4	; 
                                 .equ	PINB5	= 5	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 
                                 ; GIMSK - General Interrupt Mask Register
                                 .equ	GICR	= GIMSK	; For compatibility
                                 .equ	PCIE	= 5	; Pin Change Interrupt Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 
                                 ; GIFR - General Interrupt Flag register
                                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 
                                 ; PCMSK - Pin Change Enable Mask
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 2	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 2	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Match Output B Mode
                                 .equ	COM0B1	= 5	; Compare Match Output B Mode
                                 .equ	COM0A0	= 6	; Compare Match Output A Mode
                                 .equ	COM0A1	= 7	; Compare Match Output A Mode
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; Waveform Generation Mode
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer Conuter Register
                                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter0
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDTIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDTIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; SPL - Stack Pointer Low Byte
                                 .equ	SP0	= 0	; Stack Pointer Bit 0
                                 .equ	SP1	= 1	; Stack Pointer Bit 1
                                 .equ	SP2	= 2	; Stack Pointer Bit 2
                                 .equ	SP3	= 3	; Stack Pointer Bit 3
                                 .equ	SP4	= 4	; Stack Pointer Bit 4
                                 .equ	SP5	= 5	; Stack Pointer Bit 5
                                 .equ	SP6	= 6	; Stack Pointer Bit 6
                                 .equ	SP7	= 7	; Stack Pointer Bit 7
                                 
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	PUD	= 6	; Pull-up Disable
                                 
                                 ; MCUSR - MCU Status register
                                 .equ	PORF	= 0	; Power-On Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; OSCCAL - Oscillator Calibration Register
                                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; DWDR - Debug Wire Data Register
                                 .equ	DWDR0	= 0	; Debug Wire Data Register Bit 0
                                 .equ	DWDR1	= 1	; Debug Wire Data Register Bit 1
                                 .equ	DWDR2	= 2	; Debug Wire Data Register Bit 2
                                 .equ	DWDR3	= 3	; Debug Wire Data Register Bit 3
                                 .equ	DWDR4	= 4	; Debug Wire Data Register Bit 4
                                 .equ	DWDR5	= 5	; Debug Wire Data Register Bit 5
                                 .equ	DWDR6	= 6	; Debug Wire Data Register Bit 6
                                 .equ	DWDR7	= 7	; Debug Wire Data Register Bit 7
                                 
                                 ; SPMCSR - Store Program Memory Control and Status Register
                                 .equ	SPMEN	= 0	; Store program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	RFLB	= 3	; Read Fuse and Lock Bits
                                 .equ	CTPB	= 4	; Clear Temporary Page Buffer
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRTIM0	= 1	; Power Reduction Timer/Counter0
                                 
                                 ; BODCR - BOD Control Register
                                 .equ	BPDSE	= 0	; BOD Power-Down Sleep Enable
                                 .equ	BPDS	= 1	; BOD Power-Down in Power-Down Sleep
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	SUT0	= 2	; Select start-up time
                                 .equ	SUT1	= 3	; Select start-up time
                                 .equ	CKDIV8	= 4	; Start up with system clock divided by 8
                                 .equ	WDTON	= 5	; Watch dog timer always on
                                 .equ	EESAVE	= 6	; Keep EEprom contents during chip erase
                                 .equ	SPIEN	= 7	; SPI programming enable
                                 
                                 ; HIGH fuse bits
                                 .equ	RSTDISBL	= 0	; Disable external reset
                                 .equ	BODLEVEL0	= 1	; Enable BOD and select level
                                 .equ	BODLEVEL1	= 2	; Enable BOD and select level
                                 .equ	DWEN	= 3	; DebugWire Enable
                                 .equ	SELFPRGEN	= 4	; Self Programming Enable
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x01ff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0060
                                 .equ	SRAM_SIZE	= 64
                                 .equ	RAMEND	= 0x009f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x003f
                                 .equ	EEPROMEND	= 0x003f
                                 .equ	EEADRBITS	= 6
                                 #pragma AVRPART MEMORY PROG_FLASH 1024
                                 #pragma AVRPART MEMORY EEPROM 64
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 64
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	PAGESIZE	= 16
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                                 .equ	PCI0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	OVF0addr	= 0x0003	; Timer/Counter0 Overflow
                                 .equ	ERDYaddr	= 0x0004	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0005	; Analog Comparator
                                 .equ	OC0Aaddr	= 0x0006	; Timer/Counter Compare Match A
                                 .equ	OC0Baddr	= 0x0007	; Timer/Counter Compare Match B
                                 .equ	WDTaddr	= 0x0008	; Watchdog Time-out
                                 .equ	ADCCaddr	= 0x0009	; ADC Conversion Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 10	; size in words
                                 
                                 #endif  /* _TN13ADEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; PAL visible dots in 51.9us (498 cycles) or 166 dots
                                 ; PAL visible lines - 576
                                 
                                 .EQU	FIRST_PRINT_TV_LINE = 270	; Line where we start to print
                                 .EQU	FIRST_PRINT_TV_COLUMN = 10		; Line where we start to print
                                 .EQU	SYM_HEIGHT = 12 ;(last zero is padding byte)
                                 
                                 .EQU	VSOUT_PIN	= PB2	; Vertical sync pin
                                 .EQU	HSOUT_PIN	= PB1	; Horizontal sync pin
                                 .EQU	CONF_PIN	= PB0	; Pin for device Configuration
                                 .EQU	VBAT_PIN	= PB3	; Resistor divider for voltage measurement
                                 .EQU	VIDEO_PIN	= PB4	; OSD Video OUT
                                 
                                 .def	z0			=	r0
                                 .def	z1			=	r1
                                 .def	r_sreg		=	r2	; Store SREG register in interrupts
                                 .def	bcd			=	r3	; temp variable for BCD conversion
                                 .def	tmp			=	r16
                                 .def	tmp1		=	r17
                                 .def	tmp2		=	r4
                                 .def	itmp		=	r18	; variables to use in interrupts
                                 .def	itmp1		=	r19	; variables to use in interrupts
                                 .def	itmp2		=	r5	; variables to use in interrupts
                                 .def	sym_line_nr	=	r20 ; line number of printed text (0 based)
                                 .def	voltage		=	r21	; voltage in volts * 10 (dot will be printed in)
                                 .def	TV_lineH	=	r6 ; counter for TV lines High byte.
                                 .def	TV_lineL	=	r22 ; counter for TV lines Low byte.
                                 
                                 
                                 .DSEG
                                 .ORG 0x60
                                 ; we need buffer in SRAM for printing numbers (total 4 bytes with dot)
000060                           buff_addr:		.BYTE 4
000064                           buff_data:		.BYTE 4
000068                           TV_line_start:	.BYTE 2	; Line number where we start print data (from EEPROM)
00006a                           TV_col_start:	.BYTE 1	; Column number where to start print data (from EEPROM). 
                                 						; 10 equals about 3us.
                                 						; useful range about 1-100
                                 
                                 .CSEG
                                 .ORG 0
000000 c059                      		rjmp RESET ; Reset Handler
000001 c0c4                      		rjmp EXT_INT0 ; IRQ0 Handler
000002 9518                      		reti	;rjmp PCINT_int ; PCINT0 Handler
000003 9518                      		reti	;rjmp TIM0_OVF ; Timer0 Overflow Handler
000004 9518                      		reti	;rjmp EE_RDY ; EEPROM Ready Handler
000005 9518                      		reti	;rjmp ANA_COMP ; Analog Comparator Handler
000006 c0db                      		rjmp TIM0_COMPA ; Timer0 CompareA Handler
000007 9518                      		reti	;rjmp TIM0_COMPB ; Timer0 CompareB Handler
000008 9518                      		reti	;rjmp WATCHDOG ; Watchdog Interrupt Handler
000009 9518                      		reti	;rjmp ADC ; ADC Conversion Handler
                                 
                                 .include "font.inc"		; should be first line after interrupts vectors
                                 
                                  * font.inc
                                  *
                                  *  Created: 03-Jun-17 11:01:40 PM
                                  *   Author: Pavel
                                  */ 
                                 symbols:
00000a 7020                      sym0:	.DB 0b00100000,	0b01110000
00000b 88d8                      		.DB 0b11011000, 0b10001000
00000c 8888                      		.DB 0b10001000, 0b10001000
00000d 8888                      		.DB 0b10001000, 0b10001000
00000e 70d8                      		.DB 0b11011000, 0b01110000
00000f 0020                      		.DB 0b00100000, 0
                                 
000010 6020                      sym1:	.DB 0b00100000, 0b01100000
000011 20e0                      		.DB 0b11100000, 0b00100000
000012 2020                      		.DB 0b00100000, 0b00100000
000013 2020                      		.DB 0b00100000, 0b00100000
000014 f820                      		.DB 0b00100000, 0b11111000
000015 00f8                      		.DB 0b11111000, 0
                                 		
000016 6060                      sym2:	.DB 0b01100000, 0b01100000
000017 20e0                      		.DB 0b11100000, 0b00100000
000018 2020                      		.DB 0b00100000, 0b00100000
000019 2020                      		.DB 0b00100000, 0b00100000
00001a f820                      		.DB 0b00100000, 0b11111000
00001b 00f8                      		.DB 0b11111000, 0
                                 
00001c 60e0                      sym3:	.DB 0b11100000, 0b01100000
00001d 20e0                      		.DB 0b11100000, 0b00100000
00001e 2020                      		.DB 0b00100000, 0b00100000
00001f 2020                      		.DB 0b00100000, 0b00100000
000020 f820                      		.DB 0b00100000, 0b11111000
000021 00f8                      		.DB 0b11111000, 0
                                 
000022 6020                      sym4:	.DB 0b00100000, 0b01100000
000023 20e0                      		.DB 0b11100000, 0b00100000
000024 2020                      		.DB 0b00100000, 0b00100000
000025 2020                      		.DB 0b00100000, 0b00100000
000026 f820                      		.DB 0b00100000, 0b11111000
000027 00f8                      		.DB 0b11111000, 0
                                 
000028 6020                      sym5:	.DB 0b00100000, 0b01100000
000029 20e0                      		.DB 0b11100000, 0b00100000
00002a 2020                      		.DB 0b00100000, 0b00100000
00002b 2020                      		.DB 0b00100000, 0b00100000
00002c f820                      		.DB 0b00100000, 0b11111000
00002d 00f8                      		.DB 0b11111000, 0
                                 
00002e 603c                      sym6:	.DB 0b00111100, 0b01100000
00002f 20e0                      		.DB 0b11100000, 0b00100000
000030 2020                      		.DB 0b00100000, 0b00100000
000031 2020                      		.DB 0b00100000, 0b00100000
000032 f820                      		.DB 0b00100000, 0b11111000
000033 00f8                      		.DB 0b11111000, 0
                                 
000034 6020                      sym7:	.DB 0b00100000, 0b01100000
000035 20e0                      		.DB 0b11100000, 0b00100000
000036 2020                      		.DB 0b00100000, 0b00100000
000037 2020                      		.DB 0b00100000, 0b00100000
000038 f820                      		.DB 0b00100000, 0b11111000
000039 00f8                      		.DB 0b11111000, 0
                                 
00003a 6020                      sym8:	.DB 0b00100000, 0b01100000
00003b 20e0                      		.DB 0b11100000, 0b00100000
00003c 2020                      		.DB 0b00100000, 0b00100000
00003d 2020                      		.DB 0b00100000, 0b00100000
00003e f820                      		.DB 0b00100000, 0b11111000
00003f 00f8                      		.DB 0b11111000, 0
                                 
000040 6020                      sym9:	.DB 0b00100000, 0b01100000
000041 20e0                      		.DB 0b11100000, 0b00100000
000042 2020                      		.DB 0b00100000, 0b00100000
000043 2020                      		.DB 0b00100000, 0b00100000
000044 f820                      		.DB 0b00100000, 0b11111000
000045 00f8                      		.DB 0b11111000, 0
                                 
000046 0000                      symdot:	.DB 0b00000000, 0b00000000
000047 0000                      		.DB 0b00000000, 0b00000000
000048 0000                      		.DB 0b00000000, 0b00000000
000049 0000                      		.DB 0b00000000, 0b00000000
00004a 8080                      		.DB 0b10000000, 0b10000000
00004b 0080                      		.DB 0b10000000, 0
                                 
00004c 0000
00004d 0000
00004e 0000
00004f 0000
000050 0000
000051 0000                      symspc:	.DB 0,0,0,0,0,0,0,0,0,0,0,0
                                 .include "timer.inc"
                                 
                                  * timer.inc
                                  *
                                  *  Created: 04-Jun-17 11:00:27 AM
                                  *   Author: Pavel
                                  */ 
                                 
                                 ; these routines are called from interrupts, so use interrupt registers
                                 stop_timer:
                                 		; actually we only disable interrupt
000052 be09                      		out	TIMSK0, z0
000053 9508                      		ret
                                 
                                 start_timer:
000054 be02                      		out TCNT0, z0		; reset counter
000055 e024                      		ldi itmp, 1<<OCF0A	; reset interrupt flag
000056 bf28                      		out TIFR0, itmp
000057 e024                      		ldi itmp, 1<<OCIE0A	; enable Compare Match interrupt
000058 bf29                      		out	TIMSK0, itmp
                                 		; we don't need to reset prescaller, because we use no prescaller :)
                                 
                                 		
000059 9508                      
                                 RESET:
                                 		; change speed (ensure 9.6 mhz ossc)
00005a e800                      		ldi tmp, 1<<CLKPCE	
00005b bd06                      		out CLKPR, tmp		; enable clock cgange
00005c bc06                      		out CLKPR, z0		; prescaler 1
                                 
00005d e90f                      		ldi tmp, low(RAMEND); Main program start
00005e bf0d                      		out SPL,tmp ; Set Stack Pointer to top of RAM
                                 		
                                 		;init variables
00005f 2400                      		clr z0
000060 2411                      		clr z1
000061 9413                      		inc z1
                                 		;clr sym_line_nr	; this variable will be initialized with new page routine
000062 e75e                      		ldi voltage, 126	; for debug
                                 
                                 		; set line from where to start printing (later we store this value in EEPROM)
000063 e00e                      		ldi tmp, low(FIRST_PRINT_TV_LINE)
000064 e011                      		ldi tmp1, high(FIRST_PRINT_TV_LINE)
000065 9300 0068                 		sts TV_line_start, tmp
000067 9310 0069                 		sts TV_line_start+1, tmp1
000069 e00a                      		ldi tmp, low(FIRST_PRINT_TV_COLUMN)
00006a 9300 006a                 		sts TV_col_start, tmp
                                 
                                 		;initialize INT0 and PCINT0 interrupts
                                 		; INT0 - VIDEO Sync
                                 		; PCINT0 - Configure protocol
00006c e001                      		ldi tmp, 1<<ISC01 || 1<<ISC00	; falling edge
00006d bf05                      		out MCUCR, tmp
00006e e001                      		ldi tmp, 1<<INT0 || 1<<PCIE
00006f bf0b                      		out GIMSK, tmp
000070 e001                      		ldi tmp, 1<<CONF_PIN
000071 bb05                      		out PCMSK, tmp
                                 		
                                 		; Configure timer for CTC mode (10 us)
000072 e002                      		ldi tmp, 1<<WGM01	; CTC mode
000073 bd0f                      		out TCCR0A, tmp
000074 e001                      		ldi tmp, 1<<CS00	; no prescaling (1)
000075 bf03                      		out TCCR0B, tmp
000076 e600                      		ldi tmp, 96		; 10us at 9.6 mhz
000077 bf06                      		out	OCR0A, tmp
                                 		; Do not enable timer interrupt yet. It will be enabled only during printing data.
                                 				
000078 9478                      		sei ; Enable interrupts
                                 
                                 main_loop:
000079 cfff                      		rjmp main_loop				
                                 		
                                 ; print one char (about 3us)		
                                 PrintCharLine:
                                 ; itmp has bits for line of symbol
00007a 2455                      	clr itmp2
                                 
00007b fb20                      	bst itmp,0				;1
00007c f854                      	bld itmp2,VIDEO_PIN		;1 
00007d ba58                      	out PortB, itmp2		;1
                                 
00007e fb21                      	bst itmp,1				;1
00007f f854                      	bld itmp2,VIDEO_PIN		;1 
000080 ba58                      	out PortB, itmp2		;1
                                 
000081 fb22                      	bst itmp,2				;1
000082 f854                      	bld itmp2,VIDEO_PIN		;1 
000083 ba58                      	out PortB, itmp2		;1
                                 
000084 fb23                      	bst itmp,3				;1
000085 f854                      	bld itmp2,VIDEO_PIN		;1 
000086 ba58                      	out PortB, itmp2		;1
                                 
000087 fb24                      	bst itmp,4				;1
000088 f854                      	bld itmp2,VIDEO_PIN		;1 
000089 ba58                      	out PortB, itmp2		;1
                                 
00008a fb25                      	bst itmp,5				;1
00008b f854                      	bld itmp2,VIDEO_PIN		;1 
00008c ba58                      	out PortB, itmp2		;1
                                 
00008d 0000                      	nop						;1
00008e 0000                      	nop						;1
00008f ba08                      	out PortB,z0			;1 (clear last bit if was set)
000090 9508                      	ret
                                 	
                                 
                                 
                                 	
                                 ; this routine is called from interrupts, so use interrupt registers
                                 ; voltage is input parameter	
                                 fill_num_buff_addr:
000091 27ff                      		clr ZH
000092 e6e0                      		ldi ZL, low(buff_addr)
000093 e928                      		ldi itmp, low(symspc << 1)		; space
000094 8320                      		st Z, itmp
000095 2f25                      		mov itmp, voltage	; number to convert
000096 e634                      		ldi itmp1, 100
000097 d010                      		rcall conv_d_bcd
000098 1430                      		cp bcd, z0	;	remove leading zero
000099 f019                      		breq clear0
00009a 2c53                      		mov itmp2, bcd
00009b d012                      		rcall conv_bcd_to_address
00009c 9251                      		st Z+, itmp2
00009d e03a                      clear0:	ldi itmp1, 10
00009e d009                      		rcall conv_d_bcd
00009f 2c53                      		mov itmp2, bcd
0000a0 d00d                      		rcall conv_bcd_to_address
0000a1 9251                      		st Z+, itmp2
0000a2 e83c                      		ldi itmp1, low(symdot << 1)
0000a3 9331                      		st Z+, itmp1
0000a4 2e52                      		mov itmp2, itmp
0000a5 d008                      		rcall conv_bcd_to_address
0000a6 8250                      		st Z, itmp2
0000a7 9508                      exitbcd:ret
                                 conv_d_bcd:
0000a8 2433                      		clr bcd
0000a9 1723                      Lbcd:	cp itmp, itmp1
0000aa f3e0                      		brlo exitbcd
0000ab 9433                      		inc bcd
0000ac 1b23                      		sub itmp, itmp1
0000ad cffb                      		rjmp Lbcd
                                 
                                 
                                 ; this routine is called from interrupts, so use interrupt registers
                                 ; tmp2 contains bcd number
                                 ; Convert Char number to address
                                 conv_bcd_to_address:		
0000ae 932f                      		push itmp
0000af 933f                      		push itmp1
0000b0 e134                      		ldi itmp1, low(symbols << 1)	; we need only low address byte, because fonts are at the beginning of the flash
0000b1 e02c                      		ldi itmp, SYM_HEIGHT
0000b2 0d35                      mult1:	add itmp1, itmp2
0000b3 952a                      		dec	itmp
0000b4 f7e9                      		brne mult1
0000b5 2e53                      		mov itmp2, itmp1	; return value
0000b6 913f                      		pop itmp1
0000b7 912f                      		pop itmp
0000b8 9508                      		ret
                                 		
                                 
                                 ; this routine is called from interrupts, so use interrupt registers
                                 ; fill data buffer with printed line of bits
                                 ; current line number in sym_line_nr
                                 ; buff_addr contains addresses of every printed char
                                 fill_num_buff_data:
                                 		; so, we just need to add sym_line _nr to the address and read data from flash to sram
0000b9 e6a0                      		ldi	XL, low(buff_addr)
0000ba 27bb                      		clr XH
0000bb e6c4                      		ldi YL, low(buff_data)
0000bc 27dd                      		clr YH
0000bd 27ff                      		clr ZH
0000be e034                      		ldi itmp1, 4	; bytes to copy
0000bf 91ed                      cpybuff:ld ZL, X+
0000c0 0fe4                      		add ZL, sym_line_nr		; go to current line in char bitmap
0000c1 9124                      		lpm	itmp, Z
0000c2 9329                      		st Y+, itmp
0000c3 953a                      		dec itmp1
0000c4 f7d1                      		brne cpybuff
                                 		;inc sym_line_nr	; go to next number
0000c5 9508                      		ret
                                 
                                 ; Here we come every time when Horisontal sync is come.
                                 ; Per Datasheet it is good to use leading edge of the signal (falling)
                                 ; we come here only when new TV line is started. 
                                 ; So, we need to check VSOUT pin here to see, when new page will begin
                                 ; HSOUT: -----+_+-----+_+-----+_+-----+_+-----+_+-----+_+
                                 ; VSOUT: ---------------------+___________________+------
                                 EXT_INT0:
0000c6 b62f                      		in r_sreg, SREG
                                 		; OK start timer for 12us (in CTC mode).
                                 		; OK check VSOUT pin is LOW (New Page)
                                 		; OK if no, then 
                                 		; OK	increment line counter
                                 		; OK	(timing for printing data should be very precise, so, we will use a timer)
                                 		; OK	if line number < line where data starts, then stop timer and exit
                                 		; OK	if line number > totl lines to print, then stop timer and exit 
                                 		; OK	exit (printing will be done in Timer Compare Match interrupt)
                                 		; OK if yes, then
                                 		; OK initialize for new page (lines counter, fill sram with address of printed symbols...)
                                 		; OK stop timer and exit
0000c7 9bb2                      		sbis PINB, VSOUT_PIN
0000c8 c014                      		rjmp vsout_newpage
                                 		; HSOUT horisontal line routine
0000c9 df8a                      		rcall start_timer
0000ca 0d61                      		add	TV_lineL, z1	; +1
0000cb 1c60                      		adc	TV_lineH, z0
                                 		; check current line number
0000cc 9130 0068                 		lds itmp1, TV_line_start
0000ce 9050 0069                 		lds itmp2, TV_line_start+1
0000d0 1763                      		cp TV_lineL, itmp1
0000d1 0465                      		cpc TV_lineH, itmp2
0000d2 f038                      		brlo pcint_stop_tmr
                                 		; calculate last line to print
0000d3 e02c                      		ldi itmp, SYM_HEIGHT
0000d4 9523                      		inc itmp			; +1 for brlo comparing
0000d5 0f32                      		add	itmp1, itmp
0000d6 1c50                      		adc	itmp2, z0
0000d7 1763                      		cp TV_lineL, itmp1
0000d8 0465                      		cpc TV_lineH, itmp2
0000d9 f008                      		brlo pcint_exit		; here we exit, because we are printing
                                 		; no printing... exit
                                 pcint_stop_tmr:
0000da df77                      		rcall stop_timer
                                 pcint_exit:
0000db be2f                      		out SREG, r_sreg
0000dc 9518                      		reti
                                 
                                 ; new page routine
                                 vsout_newpage:
0000dd 2744                      		clr sym_line_nr	; start printing from the first line of symbol bitmap
0000de 2766                      		clr TV_lineL
0000df 2466                      		clr TV_lineH
0000e0 dfb0                      		rcall fill_num_buff_addr	; convert voltage to addresses of chars to print
0000e1 cff8                      		rjmp pcint_stop_tmr			; just to make sure timer is stopped
                                 
                                 
                                 ; Here we comming 10us later after Hsync captured.
                                 ; We will not use first 15us of the HLine. 
                                 ; Only about 41us of Line is 100% visible on screen.
                                 TIM0_COMPA:
                                 		; Timing here is realy critical. 
                                 		; So, be very efficient and precise with the code
0000e2 b62f                      		in r_sreg, SREG
                                 		; prepare data for printing
0000e3 dfd5                      		rcall fill_num_buff_data	; 4.7us
                                 		; Now we have delay to set horizontal position of the text
0000e4 9120 006a                 		lds	itmp, TV_col_start
                                 		; 10 iterations of this loop is about 3us.
0000e6 952a                      tmrcpl1:dec	itmp
0000e7 f7f1                      		brne tmrcpl1
                                 		; now time to start printing
0000e8 e6e4                      		ldi ZL, buff_data
0000e9 e034                      		ldi itmp1, 4
0000ea 9121                      tmrcpl2:ld itmp, Z+
0000eb df8e                      		rcall PrintCharLine
0000ec 953a                      		dec	itmp1
0000ed f7e1                      		brne tmrcpl2
0000ee 9543                      		inc sym_line_nr
0000ef be2f                      		out SREG, r_sreg


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny13A" register use summary:
x  :   1 y  :   1 z  :   7 r0 :   8 r1 :   3 r2 :   4 r3 :   5 r4 :   0 
r5 :  25 r6 :   4 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16:  20 r17:   2 r18:  28 r19:  19 r20:   3 
r21:   2 r22:   4 r23:   0 r24:   0 r25:   0 r26:   1 r27:   1 r28:   1 
r29:   1 r30:   4 r31:   2 
Registers used: 22 out of 35 (62.9%)

"ATtiny13A" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   2 add   :   4 adiw  :   0 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   6 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :   1 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   3 brlt  :   0 brmi  :   0 
brne  :   4 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   6 cbi   :   0 cbr   :   0 clc   :   0 
clh   :   0 cli   :   0 cln   :   0 clr   :  11 cls   :   0 clt   :   0 
clv   :   0 clz   :   0 com   :   0 cp    :   4 cpc   :   2 cpi   :   0 
cpse  :   0 dec   :   4 eor   :   0 icall :   0 ijmp  :   0 in    :   2 
inc   :   4 ld    :   2 ldd   :   0 ldi   :  27 lds   :   3 lpm   :   2 
lsl   :   0 lsr   :   0 mov   :   5 movw  :   0 neg   :   0 nop   :   2 
or    :   0 ori   :   0 out   :  22 pop   :   2 push  :   2 rcall :  10 
ret   :   6 reti  :   9 rjmp  :   7 rol   :   0 ror   :   0 sbc   :   0 
sbci  :   0 sbi   :   0 sbic  :   0 sbis  :   1 sbiw  :   0 sbr   :   0 
sbrc  :   0 sbrs  :   0 sec   :   0 seh   :   0 sei   :   1 sen   :   0 
ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :   6 std   :   0 sts   :   3 sub   :   1 subi  :   0 
swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 31 out of 105 (29.5%)

"ATtiny13A" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0001e2    338    144    482    1024  47.1%
[.dseg] 0x000060 0x00006b      0     11     11      64  17.2%
[.eseg] 0x000000 0x000000      0      0      0      64   0.0%

Assembly complete, 0 errors, 0 warnings
