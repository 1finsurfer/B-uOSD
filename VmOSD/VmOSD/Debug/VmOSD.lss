
AVRASM ver. 2.2.6  C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm Wed Jun 07 21:06:46 2017

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.0.79\avrasm\inc\tn13adef.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(77): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\font.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(78): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\adc.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(79): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\tvout.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(80): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\s_uart.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(81): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\eeprom.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(82): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\watchdog.inc'
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.0.79\avrasm\inc\tn13adef.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(77): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\font.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(78): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\adc.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(79): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\tvout.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(80): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\s_uart.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(81): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\eeprom.inc'
C:\git\Voltage_OSD\VmOSD\VmOSD\main.asm(82): Including file 'C:\git\Voltage_OSD\VmOSD\VmOSD\watchdog.inc'
                                 
                                 ; at 9.6mhz, 10 cycles = 1us
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATtiny13A.xml ***********
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn13Adef.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny13A
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny13A
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN13ADEF_INC_
                                 #define _TN13ADEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny13A
                                 #pragma AVRPART ADMIN PART_NAME ATtiny13A
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x90
                                 .equ	SIGNATURE_002	= 0x07
                                 
                                 #pragma AVRPART CORE CORE_VERSION V2
                                 #pragma AVRPART CORE NEW_INSTRUCTIONS lpm rd,z+
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	GIMSK	= 0x3b
                                 .equ	GIFR	= 0x3a
                                 .equ	TIMSK0	= 0x39
                                 .equ	TIFR0	= 0x38
                                 .equ	SPMCSR	= 0x37
                                 .equ	OCR0A	= 0x36
                                 .equ	MCUCR	= 0x35
                                 .equ	MCUSR	= 0x34
                                 .equ	TCCR0B	= 0x33
                                 .equ	TCNT0	= 0x32
                                 .equ	OSCCAL	= 0x31
                                 .equ	BODCR	= 0x30
                                 .equ	TCCR0A	= 0x2f
                                 .equ	DWDR	= 0x2e
                                 .equ	OCR0B	= 0x29
                                 .equ	GTCCR	= 0x28
                                 .equ	CLKPR	= 0x26
                                 .equ	PRR	= 0x25
                                 .equ	WDTCR	= 0x21
                                 .equ	EEAR	= 0x1e
                                 .equ	EEDR	= 0x1d
                                 .equ	EECR	= 0x1c
                                 .equ	PORTB	= 0x18
                                 .equ	DDRB	= 0x17
                                 .equ	PINB	= 0x16
                                 .equ	PCMSK	= 0x15
                                 .equ	DIDR0	= 0x14
                                 .equ	ACSR	= 0x08
                                 .equ	ADMUX	= 0x07
                                 .equ	ADCSRA	= 0x06
                                 .equ	ADCH	= 0x05
                                 .equ	ADCL	= 0x04
                                 .equ	ADCSRB	= 0x03
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
                                 .equ	ADLAR	= 5	; Left Adjust Result
                                 .equ	REFS0	= 6	; Reference Selection Bit 0
                                 
                                 ; ADCSRA - The ADC Control and Status register
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCH - ADC Data Register High Byte
                                 .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
                                 .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
                                 .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
                                 .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
                                 .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
                                 .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
                                 .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
                                 .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
                                 
                                 ; ADCL - ADC Data Register Low Byte
                                 .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
                                 .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
                                 .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
                                 .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
                                 .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
                                 .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
                                 .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
                                 .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
                                 
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source 2
                                 
                                 ; DIDR0 - Digital Input Disable Register 0
                                 .equ	ADC1D	= 2	; ADC2 Digital input Disable
                                 .equ	ADC3D	= 3	; ADC3 Digital input Disable
                                 .equ	ADC2D	= 4	; ADC2 Digital input Disable
                                 .equ	ADC0D	= 5	; ADC0 Digital input Disable
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ADCSRB - ADC Control and Status Register B
                                 .equ	ACME	= 6	; Analog Comparator Multiplexer Enable
                                 
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACBG	= 6	; Analog Comparator Bandgap Select
                                 .equ	AINBG	= ACBG	; For compatibility
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR0 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** EEPROM ***********************
                                 ; EEAR - EEPROM Read/Write Access
                                 .equ	EEARL	= EEAR	; For compatibility
                                 .equ	EEAR0	= 0	; EEPROM Read/Write Access bit 0
                                 .equ	EEAR1	= 1	; EEPROM Read/Write Access bit 1
                                 .equ	EEAR2	= 2	; EEPROM Read/Write Access bit 2
                                 .equ	EEAR3	= 3	; EEPROM Read/Write Access bit 3
                                 .equ	EEAR4	= 4	; EEPROM Read/Write Access bit 4
                                 .equ	EEAR5	= 5	; EEPROM Read/Write Access bit 5
                                 
                                 ; EEDR - EEPROM Data Register
                                 .equ	EEDR0	= 0	; EEPROM Data Register bit 0
                                 .equ	EEDR1	= 1	; EEPROM Data Register bit 1
                                 .equ	EEDR2	= 2	; EEPROM Data Register bit 2
                                 .equ	EEDR3	= 3	; EEPROM Data Register bit 3
                                 .equ	EEDR4	= 4	; EEPROM Data Register bit 4
                                 .equ	EEDR5	= 5	; EEPROM Data Register bit 5
                                 .equ	EEDR6	= 6	; EEPROM Data Register bit 6
                                 .equ	EEDR7	= 7	; EEPROM Data Register bit 7
                                 
                                 ; EECR - EEPROM Control Register
                                 .equ	EERE	= 0	; EEPROM Read Enable
                                 .equ	EEWE	= 1	; EEPROM Write Enable
                                 .equ	EEPE	= EEWE	; For compatibility
                                 .equ	EEMWE	= 2	; EEPROM Master Write Enable
                                 .equ	EEMPE	= EEMWE	; For compatibility
                                 .equ	EERIE	= 3	; EEProm Ready Interrupt Enable
                                 .equ	EEPM0	= 4	; 
                                 .equ	EEPM1	= 5	; 
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTB - Data Register, Port B
                                 .equ	PORTB0	= 0	; 
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; 
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; 
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; 
                                 .equ	PB3	= 3	; For compatibility
                                 .equ	PORTB4	= 4	; 
                                 .equ	PB4	= 4	; For compatibility
                                 .equ	PORTB5	= 5	; 
                                 .equ	PB5	= 5	; For compatibility
                                 
                                 ; DDRB - Data Direction Register, Port B
                                 .equ	DDB0	= 0	; 
                                 .equ	DDB1	= 1	; 
                                 .equ	DDB2	= 2	; 
                                 .equ	DDB3	= 3	; 
                                 .equ	DDB4	= 4	; 
                                 .equ	DDB5	= 5	; 
                                 
                                 ; PINB - Input Pins, Port B
                                 .equ	PINB0	= 0	; 
                                 .equ	PINB1	= 1	; 
                                 .equ	PINB2	= 2	; 
                                 .equ	PINB3	= 3	; 
                                 .equ	PINB4	= 4	; 
                                 .equ	PINB5	= 5	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; MCUCR - MCU Control Register
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 
                                 ; GIMSK - General Interrupt Mask Register
                                 .equ	GICR	= GIMSK	; For compatibility
                                 .equ	PCIE	= 5	; Pin Change Interrupt Enable
                                 .equ	INT0	= 6	; External Interrupt Request 0 Enable
                                 
                                 ; GIFR - General Interrupt Flag register
                                 .equ	PCIF	= 5	; Pin Change Interrupt Flag
                                 .equ	INTF0	= 6	; External Interrupt Flag 0
                                 
                                 ; PCMSK - Pin Change Enable Mask
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask Bit 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask Bit 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask Bit 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask Bit 3
                                 .equ	PCINT4	= 4	; Pin Change Enable Mask Bit 4
                                 .equ	PCINT5	= 5	; Pin Change Enable Mask Bit 5
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
                                 .equ	TOIE0	= 1	; Timer/Counter0 Overflow Interrupt Enable
                                 .equ	OCIE0A	= 2	; Timer/Counter0 Output Compare Match A Interrupt Enable
                                 .equ	OCIE0B	= 3	; Timer/Counter0 Output Compare Match B Interrupt Enable
                                 
                                 ; TIFR0 - Timer/Counter0 Interrupt Flag register
                                 .equ	TOV0	= 1	; Timer/Counter0 Overflow Flag
                                 .equ	OCF0A	= 2	; Timer/Counter0 Output Compare Flag 0A
                                 .equ	OCF0B	= 3	; Timer/Counter0 Output Compare Flag 0B
                                 
                                 ; OCR0A - Timer/Counter0 Output Compare Register
                                 .equ	OCR0A_0	= 0	; 
                                 .equ	OCR0A_1	= 1	; 
                                 .equ	OCR0A_2	= 2	; 
                                 .equ	OCR0A_3	= 3	; 
                                 .equ	OCR0A_4	= 4	; 
                                 .equ	OCR0A_5	= 5	; 
                                 .equ	OCR0A_6	= 6	; 
                                 .equ	OCR0A_7	= 7	; 
                                 
                                 ; TCCR0A - Timer/Counter  Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Match Output B Mode
                                 .equ	COM0B1	= 5	; Compare Match Output B Mode
                                 .equ	COM0A0	= 6	; Compare Match Output A Mode
                                 .equ	COM0A1	= 7	; Compare Match Output A Mode
                                 
                                 ; TCNT0 - Timer/Counter0
                                 .equ	TCNT0_0	= 0	; 
                                 .equ	TCNT0_1	= 1	; 
                                 .equ	TCNT0_2	= 2	; 
                                 .equ	TCNT0_3	= 3	; 
                                 .equ	TCNT0_4	= 4	; 
                                 .equ	TCNT0_5	= 5	; 
                                 .equ	TCNT0_6	= 6	; 
                                 .equ	TCNT0_7	= 7	; 
                                 
                                 ; TCCR0B - Timer/Counter Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; Waveform Generation Mode
                                 .equ	FOC0B	= 6	; Force Output Compare B
                                 .equ	FOC0A	= 7	; Force Output Compare A
                                 
                                 ; OCR0B - Timer/Counter0 Output Compare Register
                                 .equ	OCR0B_0	= 0	; 
                                 .equ	OCR0B_1	= 1	; 
                                 .equ	OCR0B_2	= 2	; 
                                 .equ	OCR0B_3	= 3	; 
                                 .equ	OCR0B_4	= 4	; 
                                 .equ	OCR0B_5	= 5	; 
                                 .equ	OCR0B_6	= 6	; 
                                 .equ	OCR0B_7	= 7	; 
                                 
                                 ; GTCCR - General Timer Conuter Register
                                 .equ	PSR10	= 0	; Prescaler Reset Timer/Counter0
                                 .equ	TSM	= 7	; Timer/Counter Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCR - Watchdog Timer Control Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDCE	= 4	; Watchdog Change Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDTIE	= 6	; Watchdog Timeout Interrupt Enable
                                 .equ	WDTIF	= 7	; Watchdog Timeout Interrupt Flag
                                 
                                 
                                 ; ***** CPU **************************
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; SPL - Stack Pointer Low Byte
                                 .equ	SP0	= 0	; Stack Pointer Bit 0
                                 .equ	SP1	= 1	; Stack Pointer Bit 1
                                 .equ	SP2	= 2	; Stack Pointer Bit 2
                                 .equ	SP3	= 3	; Stack Pointer Bit 3
                                 .equ	SP4	= 4	; Stack Pointer Bit 4
                                 .equ	SP5	= 5	; Stack Pointer Bit 5
                                 .equ	SP6	= 6	; Stack Pointer Bit 6
                                 .equ	SP7	= 7	; Stack Pointer Bit 7
                                 
                                 ; MCUCR - MCU Control Register
                                 ;.equ	ISC00	= 0	; Interrupt Sense Control 0 bit 0
                                 ;.equ	ISC01	= 1	; Interrupt Sense Control 0 bit 1
                                 .equ	SM0	= 3	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 4	; Sleep Mode Select Bit 1
                                 .equ	SE	= 5	; Sleep Enable
                                 .equ	PUD	= 6	; Pull-up Disable
                                 
                                 ; MCUSR - MCU Status register
                                 .equ	PORF	= 0	; Power-On Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	BORF	= 2	; Brown-out Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; OSCCAL - Oscillator Calibration Register
                                 .equ	CAL0	= 0	; Oscillatro Calibration Value Bit 0
                                 .equ	CAL1	= 1	; Oscillatro Calibration Value Bit 1
                                 .equ	CAL2	= 2	; Oscillatro Calibration Value Bit 2
                                 .equ	CAL3	= 3	; Oscillatro Calibration Value Bit 3
                                 .equ	CAL4	= 4	; Oscillatro Calibration Value Bit 4
                                 .equ	CAL5	= 5	; Oscillatro Calibration Value Bit 5
                                 .equ	CAL6	= 6	; Oscillatro Calibration Value Bit 6
                                 
                                 ; CLKPR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
                                 
                                 ; DWDR - Debug Wire Data Register
                                 .equ	DWDR0	= 0	; Debug Wire Data Register Bit 0
                                 .equ	DWDR1	= 1	; Debug Wire Data Register Bit 1
                                 .equ	DWDR2	= 2	; Debug Wire Data Register Bit 2
                                 .equ	DWDR3	= 3	; Debug Wire Data Register Bit 3
                                 .equ	DWDR4	= 4	; Debug Wire Data Register Bit 4
                                 .equ	DWDR5	= 5	; Debug Wire Data Register Bit 5
                                 .equ	DWDR6	= 6	; Debug Wire Data Register Bit 6
                                 .equ	DWDR7	= 7	; Debug Wire Data Register Bit 7
                                 
                                 ; SPMCSR - Store Program Memory Control and Status Register
                                 .equ	SPMEN	= 0	; Store program Memory Enable
                                 .equ	PGERS	= 1	; Page Erase
                                 .equ	PGWRT	= 2	; Page Write
                                 .equ	RFLB	= 3	; Read Fuse and Lock Bits
                                 .equ	CTPB	= 4	; Clear Temporary Page Buffer
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRADC	= 0	; Power Reduction ADC
                                 .equ	PRTIM0	= 1	; Power Reduction Timer/Counter0
                                 
                                 ; BODCR - BOD Control Register
                                 .equ	BPDSE	= 0	; BOD Power-Down Sleep Enable
                                 .equ	BPDS	= 1	; BOD Power-Down in Power-Down Sleep
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; LOW fuse bits
                                 .equ	CKSEL0	= 0	; Select Clock Source
                                 .equ	CKSEL1	= 1	; Select Clock Source
                                 .equ	SUT0	= 2	; Select start-up time
                                 .equ	SUT1	= 3	; Select start-up time
                                 .equ	CKDIV8	= 4	; Start up with system clock divided by 8
                                 .equ	WDTON	= 5	; Watch dog timer always on
                                 .equ	EESAVE	= 6	; Keep EEprom contents during chip erase
                                 .equ	SPIEN	= 7	; SPI programming enable
                                 
                                 ; HIGH fuse bits
                                 .equ	RSTDISBL	= 0	; Disable external reset
                                 .equ	BODLEVEL0	= 1	; Enable BOD and select level
                                 .equ	BODLEVEL1	= 2	; Enable BOD and select level
                                 .equ	DWEN	= 3	; DebugWire Enable
                                 .equ	SELFPRGEN	= 4	; Self Programming Enable
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x01ff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0060
                                 .equ	SRAM_SIZE	= 64
                                 .equ	RAMEND	= 0x009f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x003f
                                 .equ	EEPROMEND	= 0x003f
                                 .equ	EEADRBITS	= 6
                                 #pragma AVRPART MEMORY PROG_FLASH 1024
                                 #pragma AVRPART MEMORY EEPROM 64
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 64
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x60
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	PAGESIZE	= 16
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt 0
                                 .equ	PCI0addr	= 0x0002	; External Interrupt Request 0
                                 .equ	OVF0addr	= 0x0003	; Timer/Counter0 Overflow
                                 .equ	ERDYaddr	= 0x0004	; EEPROM Ready
                                 .equ	ACIaddr	= 0x0005	; Analog Comparator
                                 .equ	OC0Aaddr	= 0x0006	; Timer/Counter Compare Match A
                                 .equ	OC0Baddr	= 0x0007	; Timer/Counter Compare Match B
                                 .equ	WDTaddr	= 0x0008	; Watchdog Time-out
                                 .equ	ADCCaddr	= 0x0009	; ADC Conversion Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 10	; size in words
                                 
                                 #endif  /* _TN13ADEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 .EQU	CRYSTAL_FREQ 	= 9600000	; Hz
                                 .EQU	BAUD 		 	= 19200 	; bps
                                 .EQU 	SYMBOL_STRETCH 	= 2		; copy every line of symbol SYMBOL_STRETCH times
                                 
                                 ; PAL visible dots in 51.9us (498 cycles) or 166 dots
                                 ; PAL visible lines - 576
                                 
                                 
                                 .EQU	FIRST_PRINT_TV_LINE 	= 200	; Line where we start to print
                                 .EQU	FIRST_PRINT_TV_COLUMN 	= 30	; Line where we start to print
                                 .EQU	VOLT_DIV_CONST			= 186	; To get this number use formula: 4095/(Vmax*10)*8, where Vmax=(R1+R2)*Vref/R2, where Vref=1.1v and resistor values is from divider (15K/1K)
                                 										; Vmax=(15+1)*1.1/1=17.6
                                 										; 4095/(17.6*10)*8=186
                                 										; For resistors 20K/1K constant will be 141 (max 5S battery). 
                                 										
                                 .EQU	SYM_HEIGHT 				= 12 	;(last zero is padding byte)
                                 
                                 .EQU	VSOUT_PIN	= PB2	; Vertical sync pin
                                 .EQU	HSOUT_PIN	= PB1	; Horizontal sync pin (Seems CSOUT pin is more reliable)
                                 .EQU	CONF_PIN	= PB0	; Pin for device Configuration
                                 .EQU	VBAT_PIN	= PB3	; Resistor divider (15K/1K) for voltage measurement (4S max)
                                 .EQU	VIDEO_PIN	= PB4	; OSD Video OUT
                                 
                                 .def	z0			=	r0
                                 .def	z1			=	r1
                                 .def	r_sreg		=	r2	; Store SREG register in interrupts
                                 .def	tmp			=	r16
                                 .def	tmp1		=	r17
                                 .def	tmp2		=	r3
                                 .def	itmp		=	r18	; variables to use in interrupts
                                 .def	itmp1		=	r19	; variables to use in interrupts
                                 .def	itmp2		=	r4	; variables to use in interrupts
                                 .def	voltage		=	r20	; voltage in volts * 10 (dot will be printed in)
                                 .def	sym_line_nr	=	r5 	; line number of printed text (0 based)
                                 .def	sym_H_cntr	=	r21	; counter for symbol stretching
                                 ;						r22
                                 ;						r23
                                 .def	TV_lineL	=	r24 ; counter for TV lines Low byte. (don't change register mapping here)
                                 .def	TV_lineH	=	r25 ; counter for TV lines High byte. (don't change register mapping here)
                                 .def	adc_cntr	=	r6	; counter for ADC readings
                                 .def	adc_sumL	=	r7	; accumulated readings of ADC (sum of 64 values)
                                 .def	adc_sumH	=	r8	; accumulated readings of ADC (sum of 64 values)
                                 ; Variables XL:XH, YL:YH, ZL:ZH are used in interrupts, so only use them in main code when interrupts are disabled
                                 
                                 .DSEG
                                 .ORG 0x60
                                 ; we need buffer in SRAM for printing numbers (total 4 bytes with dot)
000060                           buff_addr:		.BYTE 4
000064                           buff_data:		.BYTE 4
000068                           TV_line_start:	.BYTE 2	; Line number where we start print data (from EEPROM)
00006a                           TV_col_start:	.BYTE 1	; Column number where to start print data (from EEPROM). 
                                 						; 10 equals about 3us.
                                 						; useful range about 1-100
00006b                           Bat_correction:	.BYTE 1 ; signed value in mV (1=100mV) for correcting analog readings (from EEPROM).
                                 
                                 .ESEG
                                 .ORG 5				; It is good practice do not use first bytes of EEPROM to prevet its corruption
                                 EEPROM_Start:
000005                           EE_TV_line_start:	.BYTE 2
000007                           EE_TV_col_start:	.BYTE 1
000008                           EE_Bat_correction:	.BYTE 1 
                                 
                                 .CSEG
                                 .ORG 0
000000 c186                      		rjmp RESET ; Reset Handler
000001 c099                      		rjmp EXT_INT0 ; IRQ0 Handler
000002 9518                      		reti	;rjmp PCINT_int ; PCINT0 Handler
000003 9518                      		reti	;rjmp TIM0_OVF ; Timer0 Overflow Handler
000004 9518                      		reti	;rjmp EE_RDY ; EEPROM Ready Handler
000005 9518                      		reti	;rjmp ANA_COMP ; Analog Comparator Handler
000006 9518                      		reti	;rjmp TIM0_COMPA ; Timer0 CompareA Handler
000007 9518                      		reti	;rjmp TIM0_COMPB ; Timer0 CompareB Handler
000008 c17a                      		rjmp WATCHDOG ; Watchdog Interrupt Handler
000009 9518                      		reti	;rjmp ADC ; ADC Conversion Handler
                                 
                                 .include "font.inc"		; should be first line after interrupts vectors
                                 
                                  * font.inc
                                  *
                                  *  Created: 03-Jun-17 
                                  *   Author: Pavel
                                  */ 
                                 symbols:
                                 sym0:	.DB 0b00100000, \
                                 			0b01110000, \
00000a 7020                      			0b11011000, \
                                 			0b10001000, \
00000b 88d8                      			0b10001000, \
                                 			0b10001000, \
00000c 8888                      			0b10001000, \
                                 			0b10001000, \
00000d 8888                      			0b11011000, \
                                 			0b01110000, \
00000e 70d8                      			0b00100000, \
00000f 0020                      			0
                                 
                                 sym1:	.DB 0b00100000, \
                                 			0b01100000, \
000010 6020                      			0b11100000, \
                                 			0b00100000, \
000011 20e0                      			0b00100000, \
                                 			0b00100000, \
000012 2020                      			0b00100000, \
                                 			0b00100000, \
000013 2020                      			0b00100000, \
                                 			0b11111000, \
000014 f820                      			0b11111000, \
000015 00f8                      			0
                                 		
000016 d870                      sym2:	.DB 0b01110000, 0b11011000
000017 0808                      		.DB 0b00001000, 0b00001000
000018 1808                      		.DB 0b00001000, 0b00011000
000019 6030                      		.DB 0b00110000, 0b01100000
00001a f8c0                      		.DB 0b11000000, 0b11111000
00001b 00f8                      		.DB 0b11111000, 0
                                 
00001c 6020                      sym3:	.DB 0b00100000, 0b01100000
00001d 20e0                      		.DB 0b11100000, 0b00100000
00001e 2020                      		.DB 0b00100000, 0b00100000
00001f 2020                      		.DB 0b00100000, 0b00100000
000020 f820                      		.DB 0b00100000, 0b11111000
000021 00f8                      		.DB 0b11111000, 0
                                 
000022 6020                      sym4:	.DB 0b00100000, 0b01100000
000023 20e0                      		.DB 0b11100000, 0b00100000
000024 2020                      		.DB 0b00100000, 0b00100000
000025 2020                      		.DB 0b00100000, 0b00100000
000026 f820                      		.DB 0b00100000, 0b11111000
000027 00f8                      		.DB 0b11111000, 0
                                 
000028 6020                      sym5:	.DB 0b00100000, 0b01100000
000029 20e0                      		.DB 0b11100000, 0b00100000
00002a 2020                      		.DB 0b00100000, 0b00100000
00002b 2020                      		.DB 0b00100000, 0b00100000
00002c f820                      		.DB 0b00100000, 0b11111000
00002d 00f8                      		.DB 0b11111000, 0
                                 
00002e 7030                      sym6:	.DB 0b00110000, 0b01110000
00002f 80c0                      		.DB 0b11000000, 0b10000000
000030 f8f0                      		.DB 0b11110000, 0b11111000
000031 8888                      		.DB 0b10001000, 0b10001000
000032 f888                      		.DB 0b10001000, 0b11111000
000033 0070                      		.DB 0b01110000, 0
                                 
000034 f8f8                      sym7:	.DB 0b11111000, 0b11111000
000035 0888                      		.DB 0b10001000, 0b00001000
000036 1010                      		.DB 0b00010000, 0b00010000
000037 2010                      		.DB 0b00010000, 0b00100000
000038 2020                      		.DB 0b00100000, 0b00100000
000039 0020                      		.DB 0b00100000, 0
                                 
00003a 6020                      sym8:	.DB 0b00100000, 0b01100000
00003b 20e0                      		.DB 0b11100000, 0b00100000
00003c 2020                      		.DB 0b00100000, 0b00100000
00003d 2020                      		.DB 0b00100000, 0b00100000
00003e f820                      		.DB 0b00100000, 0b11111000
00003f 00f8                      		.DB 0b11111000, 0
                                 
000040 6020                      sym9:	.DB 0b00100000, 0b01100000
000041 20e0                      		.DB 0b11100000, 0b00100000
000042 2020                      		.DB 0b00100000, 0b00100000
000043 2020                      		.DB 0b00100000, 0b00100000
000044 f820                      		.DB 0b00100000, 0b11111000
000045 00f8                      		.DB 0b11111000, 0
                                 
000046 0000                      symdot:	.DB 0b00000000, 0b00000000
000047 0000                      		.DB 0b00000000, 0b00000000
000048 0000                      		.DB 0b00000000, 0b00000000
000049 0000                      		.DB 0b00000000, 0b00000000
00004a 6060                      		.DB 0b01100000, 0b01100000
00004b 0060                      		.DB 0b01100000, 0
                                 
00004c 0000
00004d 0000
00004e 0000
00004f 0000
000050 0000
000051 0000                      symspc:	.DB 0,0,0,0,0,0,0,0,0,0,0,0
                                 .include "adc.inc"
                                 
                                  * adc.inc
                                  *
                                  *  Created: 04-Jun-17
                                  *   Author: Pavel
                                  */ 
                                 
                                 ; ADC reading
                                 ; We come to this routine after ADC conversion is finished
                                 ; First we need to accumulate 64 ADC 10 bit readings.
                                 ; Then we will divide the sum by 16 getting 12 bit ADC! (aka Oversampling)
                                 ; At the end we will convert ADC value to volts (actually volts*10 for easy printing)
                                 ReadVoltage:
                                 		; read current ADC
000052 b104                      		in tmp, ADCL
000053 b115                      		in tmp1, ADCH
000054 9a36                      		sbi ADCSRA, ADSC		; start new conversion
                                 		; accumulate readings
000055 0e70                      		add adc_sumL, tmp
000056 1e81                      		adc adc_sumH, tmp1
000057 9463                      		inc adc_cntr
                                 		; check adc_cntr. Did we collected all data?
000058 e400                      		ldi tmp, 64
000059 1660                      		cp adc_cntr, tmp
00005a f088                      		brlo adc_exit	; continue to accumulate ADC readings
                                 		; data is ready for converting
00005b 2466                      		clr adc_cntr	; reset counter
                                 		; Oversamping the result(divide by 16)
                                 		; But actually we divide only by 2, to preserve precision in integer math
00005c 9486                      		lsr adc_sumH
00005d 9477                      		ror adc_sumL
                                 		; Now we use constant VOLT_DIV_CONST.
                                 		; And to get voltage (Vin*10) we divide ADC Oversampled value by our calculated constant 
00005e eb0a                      		ldi tmp, VOLT_DIV_CONST
00005f 2433                      		clr tmp2	; result will be here
000060 1670                      adc_L1:	cp adc_sumL, tmp
000061 0480                      		cpc adc_sumH, z0
000062 f020                      		brlo adc_3
000063 9433                      		inc tmp2
000064 1a70                      		sub adc_sumL, tmp
000065 0880                      		sbc	adc_sumH, z0
000066 cff9                      		rjmp adc_L1
                                 adc_3:	; now we have reminder in adc_sumL. Lets add it to the final result
000067 9506                      		lsr tmp	; divide constant by 2
000068 1670                      		cp adc_sumL, tmp
000069 f008                      		brlo adc_4
00006a 9433                      		inc tmp2	; add 1 (actually it is 0.1) to the result if reminder is 0.5 or greather
00006b 2d43                      adc_4:	mov voltage, tmp2	; now we have beautiful result for printing
                                 adc_exit:
00006c 9508                      		ret
                                 .include "tvout.inc"
                                 
                                  * tvout.inc
                                  *
                                  *  Created: 04-Jun-17
                                  *   Author: Pavel
                                  */ 
                                 
                                 	
                                 ; this routine is called from interrupts, so use interrupt registers
                                 ; voltage is input parameter	
                                 fill_num_buff_addr:
00006d 27ff                      		clr ZH
00006e e6e0                      		ldi ZL, low(buff_addr)
00006f e928                      		ldi itmp, low(symspc << 1)		; space
000070 8320                      		st Z, itmp
000071 2f24                      		mov itmp, voltage	; number to convert
000072 e634                      		ldi itmp1, 100
000073 d00e                      		rcall conv_d_bcd
000074 1440                      		cp itmp2, z0	;	remove leading zero
000075 f011                      		breq clear0
000076 d011                      		rcall conv_bcd_to_address
000077 9241                      		st Z+, itmp2
000078 e03a                      clear0:	ldi itmp1, 10
000079 d008                      		rcall conv_d_bcd
00007a d00d                      		rcall conv_bcd_to_address
00007b 9241                      		st Z+, itmp2
00007c e83c                      		ldi itmp1, low(symdot << 1)
00007d 9331                      		st Z+, itmp1
00007e 2e42                      		mov itmp2, itmp
00007f d008                      		rcall conv_bcd_to_address
000080 8240                      		st Z, itmp2
000081 9508                      exitbcd:ret
                                 conv_d_bcd:
000082 2444                      		clr itmp2
000083 1723                      Lbcd:	cp itmp, itmp1
000084 f3e0                      		brlo exitbcd
000085 9443                      		inc itmp2
000086 1b23                      		sub itmp, itmp1
000087 cffb                      		rjmp Lbcd
                                 
                                 
                                 ; this routine is called from interrupts, so use interrupt registers
                                 ; tmp2 contains bcd number
                                 ; Convert Char number to address
                                 conv_bcd_to_address:		
                                 		; use XH register just because it is free 
000088 e1b4                      		ldi XH, low(symbols << 1)	; we need only low address byte, because fonts are at the beginning of the flash
000089 5fb4                      mult1:	subi XH, -SYM_HEIGHT	; XH=XH+12
00008a 944a                      		dec	itmp2
00008b f7e9                      		brne mult1
00008c 2e4b                      		mov itmp2, XH	; return value
00008d 9508                      		ret
                                 		
                                 
                                 ; this routine is called from interrupts, so use interrupt registers
                                 ; fill data buffer with printed line of bits
                                 ; current line number in sym_line_nr
                                 ; buff_addr contains addresses of every printed char
                                 fill_num_buff_data:
                                 		; so, we just need to add sym_line _nr to the address and read data from flash to sram
00008e e6a0                      		ldi	XL, low(buff_addr)
00008f 27bb                      		clr XH
000090 e6c4                      		ldi YL, low(buff_data)
000091 27dd                      		clr YH
000092 27ff                      		clr ZH
000093 e034                      		ldi itmp1, 4	; bytes to copy
000094 91ed                      cpybuff:ld ZL, X+
000095 0de5                      		add ZL, sym_line_nr		; go to current line in char bitmap
000096 9124                      		lpm	itmp, Z
000097 9329                      		st Y+, itmp
000098 953a                      		dec itmp1
000099 f7d1                      		brne cpybuff
00009a 9508                      		ret
                                 		
                                 
                                 ; Here we come every time when Horisontal sync is come.
                                 ; Per Datasheet it is good to use leading edge of the signal (falling)
                                 ; we come here only when new TV line is started. 
                                 ; So, we need to check VSOUT pin here to see, when new page will begin
                                 ; CSOUT: -----+_+-----+_+-----+_+-----+_+-----+_+-----+_+
                                 ; VSOUT: ---------------------+___________________+------
                                 EXT_INT0:
00009b b62f                      		in r_sreg, SREG
                                 		; OK check VSOUT pin is LOW (New Page)
                                 		; OK if no, then 
                                 		; OK	increment line counter
                                 		; OK	(timing for printing data should be very precise)
                                 		; OK	if line number < line where data starts, then exit
                                 		; OK	if line number > totl lines to print, then exit 
                                 		; OK	Print OSD
                                 		; OK if yes, then
                                 		; OK initialize for new page (lines counter, fill sram with address of printed symbols...)
                                 		; OK exit
00009c 9bb2                      		sbis PINB, VSOUT_PIN
00009d c031                      		rjmp vsout_newpage
                                 		; HSOUT horisontal line routine
00009e 9601                      		adiw TV_lineH:TV_lineL, 1	; inc TV_lineL:TV_lineH
                                 		; check current line number (we are using XH:XL just for sake of use adiw next)
00009f 91a0 0068                 		lds XL, TV_line_start
0000a1 91b0 0069                 		lds XH, TV_line_start+1
0000a3 178a                      		cp TV_lineL, XL
0000a4 079b                      		cpc TV_lineH, XH
0000a5 f138                      		brlo pcint_exit			; not needed to print yet
                                 		; calculate last line to print
0000a6 9658                      		adiw XH:XL, SYM_HEIGHT * SYMBOL_STRETCH
0000a7 178a                      		cp TV_lineL, XL
0000a8 079b                      		cpc TV_lineH, XH
0000a9 f518                      		brsh pcint_exit		; printing is finished, just exit
                                 		
                                 		;  printing...
                                 		; We will not use first 15us of the HLine. And we can't because of code running at the beginning every line :)
                                 		; Only about 41us of Line is 100% visible on screen.
                                 		; prepare data for printing
0000aa dfe3                      		rcall fill_num_buff_data	; 4.7us
                                 		; Now is the delay to set horizontal position of the text
0000ab 9120 006a                 		lds	itmp, TV_col_start
                                 		; 10 iterations of this loop is about 3us.
0000ad 952a                      tmrcpl1:dec	itmp
0000ae f7f1                      		brne tmrcpl1
                                 		; now time to start printing
0000af e6e4                      		ldi ZL, low(buff_data)
0000b0 27ff                      		clr ZH
0000b1 e034                      		ldi itmp1, 4
0000b2 2444                      		clr itmp2
0000b3 9121                      tmrcpl2:ld itmp, Z+
                                 		; print one char line (about 3us)		
                                 		; itmp has bits for line of symbol
                                 		; ### START OF TV OUT ###
0000b4 fb27                      		bst itmp,7				;1
0000b5 f844                      		bld itmp2,VIDEO_PIN		;1 
0000b6 ba48                      		out PORTB, itmp2		;1
                                 
0000b7 fb26                      		bst itmp,6				;1
0000b8 f844                      		bld itmp2,VIDEO_PIN		;1 
0000b9 ba48                      		out PORTB, itmp2		;1
                                 
0000ba fb25                      		bst itmp,5				;1
0000bb f844                      		bld itmp2,VIDEO_PIN		;1 
0000bc ba48                      		out PORTB, itmp2		;1
                                 
0000bd fb24                      		bst itmp,4				;1
0000be f844                      		bld itmp2,VIDEO_PIN		;1 
0000bf ba48                      		out PORTB, itmp2		;1
                                 
0000c0 fb23                      		bst itmp,3				;1
0000c1 f844                      		bld itmp2,VIDEO_PIN		;1 
0000c2 ba48                      		out PORTB, itmp2		;1
                                 
                                 		;bst itmp,2				;1
                                 		;bld itmp2,VIDEO_PIN		;1 
                                 		;out PORTB, itmp2		;1
                                 
0000c3 94e8                      		clt						;1 clear last bit if was set
0000c4 f844                      		bld itmp2,VIDEO_PIN		;1
0000c5 ba48                      		out PORTB,itmp2			;1
                                 
0000c6 953a                      		dec	itmp1
0000c7 f759                      		brne tmrcpl2
                                 		; ### END OF TV OUT ###
                                 		
0000c8 9ac0                      		sbi	PORTB, CONF_PIN		; restore back pullup for Configure pin
0000c9 955a                      		dec sym_H_cntr
0000ca f411                      		brne pcint_exit	; skip sym_line_nr++ if sym_H_cntr not 0
0000cb 9453                      		inc sym_line_nr	; go to next line of symbol
0000cc e052                      		ldi sym_H_cntr, SYMBOL_STRETCH
                                 		
                                 pcint_exit:
0000cd be2f                      		out SREG, r_sreg
0000ce 9518                      		reti
                                 
                                 ; new page routine
                                 vsout_newpage:
0000cf 2455                      		clr sym_line_nr	; Reset printing counter. Start printing from the first line of symbol bitmap
0000d0 2788                      		clr TV_lineL
0000d1 2799                      		clr TV_lineH
0000d2 e052                      		ldi sym_H_cntr, SYMBOL_STRETCH
0000d3 df99                      		rcall fill_num_buff_addr	; convert voltage to addresses of chars to print
0000d4 cff8                      		rjmp pcint_exit				; exit
                                 
                                 .include "s_uart.inc"
                                 
                                 ;pure cycles necessary per bit
                                 .equ	DELAY_C = CRYSTAL_FREQ / BAUD			
                                 .equ 	DELAY_COUNT	= (DELAY_C - 23) / 6	; this is more correct
                                 
                                 ; throw error if we're out of bounds
                                 .if DELAY_COUNT > 255
                                 .elif DELAY_COUNT <= 0
                                 .endif
                                 
                                 		
                                 ; UART -> tmp2
                                 UART_get_byte:	
0000d5 930f                      		push tmp
                                 
                                 ; we wait only some milliseconds for start bit. If symbols not arrive, then seems transfer is finished
0000d6 d070                      		rcall wait_for_start_short
                                 
0000d7 e019                      		ldi tmp1, 9			;8 data bit + 1 stop bit
                                 		;synchronize for 0.5 bit length
0000d8 d00b                      		rcall UART_delay	
                                 
                                 uart_get_bit:	
0000d9 d00a                      		rcall UART_delay	
0000da d009                      		rcall UART_delay		
                                 
0000db 9488                      		clc			
0000dc 99b0                      		sbic PINB, CONF_PIN	
0000dd 9408                      		sec			
                                 		
0000de 951a                      		dec tmp1		
0000df f011                      		breq uart_bit_done	
                                 					
0000e0 9437                      		ror tmp2		
0000e1 cff7                      		rjmp uart_get_bit	
                                 
                                 uart_bit_done:	
0000e2 910f                      		pop tmp
0000e3 9508                      		ret
                                 
                                 ; 3·DELAY_COUNT + 7 cycles (including rcall(3) and ret(4))
                                 UART_delay:	
0000e4 e40f                      		ldi tmp, DELAY_COUNT		;1
                                 UART_delay1:	
0000e5 950a                      		dec	tmp						;1
0000e6 f7f1                      		brne UART_delay1			;2
0000e7 9508                      		ret							;4
                                 
                                 	
                                 EnterCommandMode:
0000e8 94f8                      		cli	; disable interrupts (no TVout) due to critical timing on UART transmission
                                 		; We first receive 0x55, to enable Serial
                                 		; wait until port stabilize (all 0x55 char is received)
0000e9 d054                      		rcall SA_Wait_Transfer_Compelted
                                 		; Now wait for characters
0000ea d05c                      Cm_wt:	rcall wait_for_start_short	; we should wait for first bit forever...
0000eb 1430                      		cp tmp2, z0
0000ec f3e9                      		breq Cm_wt
                                 		; something started to come
                                 		; First byte is Parameter, other three is number 000
                                 		; we can reuse buff_data buffer to receive data
0000ed e004                      		ldi tmp, 4		; receive 4 bytes
0000ee e6e4                      		ldi ZL, low(buff_data)
0000ef 27ff                      		clr ZH
0000f0 dfe4                      Cm_LB:	rcall UART_get_byte
0000f1 9231                      		st Z+, tmp2
0000f2 950a                      		dec tmp
0000f3 f7e1                      		brne Cm_LB
                                 		; Parse buffer
                                 		; Available commands:
                                 		;  XXXX - Exit from Command mode without saving settings to EEPROM
                                 		;  SSSS - Save settings to EEPROM and Exit
                                 		;  Lnnn - Set start TV line number for printed text
                                 		;  Cnnn - Set TV column number for printed text
                                 		;  Vnnn - Battery voltage correction
                                 		;  RRRR - Reset to Factory settings
                                 		;  TTTT - Test settings (show OSD for 5 seconds)
0000f4 e6e4                      		ldi ZL, low(buff_data)
0000f5 27ff                      		clr ZH
0000f6 9101                      		ld tmp, Z+
0000f7 3508                      		cpi tmp, 'X'
0000f8 f051                      		breq Cm_Exit
0000f9 3503                      		cpi tmp, 'S'
0000fa f051                      		breq Cm_Save
0000fb 340c                      		cpi tmp, 'L'
0000fc f079                      		breq Cm_TVLine
0000fd 3403                      		cpi tmp, 'C'
0000fe f0a9                      		breq Cm_TVColumn
0000ff 3506                      		cpi tmp, 'V'
000100 f0c9                      		breq Cm_Battery
000101 3502                      		cpi tmp, 'R'
000102 f0e9                      		breq Cm_Factory_reset
                                 
                                 
                                 Cm_Exit:	; exit from command mode
000103 9478                      		sei		; enable TVout
000104 9508                      		ret
                                 
                                 Cm_Save:
                                 		; save all data to EEPROM and exit
                                 		; because this is very sensitive operation, lets double check it. Check remaining buffer for 'SSS'
000105 e013                      		ldi tmp1, 3
000106 9101                      Cm_SL1:	ld tmp, Z+
000107 3503                      		cpi tmp, 'S'
000108 f6f9                      		brne EnterCommandMode		; Seems command is not 'SSSS' go back to command mode. Save nothing to EEPROM
000109 951a                      		dec tmp1
00010a f7d9                      		brne Cm_SL1
                                 		; TODO EEPROM save
00010b cff7                      		rjmp Cm_Exit
                                 
                                 Cm_TVLine:
                                 		;OK Convert remaining buffer to 16bit number
                                 		;-- Check number for allowed range
                                 		;OK Update SRAM variable
                                 		;   Show OSD for 4 seconds
                                 		;OK Go back to Command Mode
00010c d01c                      		rcall Cm_ConvertBCD16bit
                                 		; now we have a number in adc_sumL:adc_sumH
00010d 9270 0068                 		sts TV_line_start, adc_sumL
00010f 9280 0069                 		sts TV_line_start+1, adc_sumH
000111 d05f                      		rcall WDT_Start_4s			; run WDT in interrupt mode
000112 d03f                      		rcall EnableTVout4sec
000113 cfd4                      		rjmp EnterCommandMode		; go back to Command Mode
                                 
                                 Cm_TVColumn:
                                 		;OK Convert remaining buffer to 16bit number
                                 		;-- Check number for allowed range
                                 		;OK Update SRAM variable
                                 		;   Show OSD for 4 seconds
                                 		;OK Go back to Command Mode
000114 d014                      		rcall Cm_ConvertBCD16bit
                                 		; now we have a number in adc_sumL:adc_sumH
000115 9270 006a                 		sts TV_col_start, adc_sumL
000117 d059                      		rcall WDT_Start_4s			; run WDT in interrupt mode
000118 d039                      		rcall EnableTVout4sec
000119 cfce                      		rjmp EnterCommandMode		; go back to Command Mode
                                 
                                 Cm_Battery:
                                 		;OK Convert remaining buffer to 16bit number
                                 		;-- Check number for allowed range
                                 		;OK Update SRAM variable
                                 		;   Show OSD for 4 seconds
                                 		;OK Go back to Command Mode
00011a d00e                      		rcall Cm_ConvertBCD16bit
                                 		; now we have a number in adc_sumL:adc_sumH
00011b 9270 006b                 		sts Bat_correction, adc_sumL
00011d d053                      		rcall WDT_Start_4s			; run WDT in interrupt mode
00011e d033                      		rcall EnableTVout4sec
00011f cfc8                      		rjmp EnterCommandMode		; go back to Command Mode
                                 		
                                 Cm_Factory_reset:
                                 		; because this is very sensitive operation, lets double check it. Check remaining buffer for 'RRR'
000120 e013                      		ldi tmp1, 3
000121 9101                      Cm_Fr1:	ld tmp, Z+
000122 3502                      		cpi tmp, 'R'
000123 f621                      		brne EnterCommandMode		; Seems command is not 'RRRR' go back to command mode. Save nothing to EEPROM
000124 951a                      		dec tmp1
000125 f7d9                      		brne Cm_Fr1
000126 d041                      		rcall EE_Reset_factory
                                 		; initiate a reset
000127 d04b                      		rcall WDT_Start_16ms
000128 cfff                      Cm_Fr2:	rjmp Cm_Fr2					; wait until WDT reset
                                 
                                 
                                 ; Convert 3 bytes from SRAM pointed by Z register to 16bit number (adc_sumL:adc_sumH)
                                 Cm_ConvertBCD16bit:
000129 2477                      		clr adc_sumL	; reuse adc variables for storing 16 bit number
00012a 2488                      		clr adc_sumH	; reuse adc variables for storing 16 bit number
00012b 9101                      		ld tmp, Z+		; read 100s of number
00012c 700f                      		andi tmp, 0b00001111	; converd BCD to bin
                                 		; multiply by 100
00012d e312                      		ldi tmp1, 50	; multiply by 50
00012e d009                      		rcall Cm_multiply
00012f 9101                      		ld tmp, Z+		; read 10s of number
000130 700f                      		andi tmp, 0b00001111	; converd BCD to bin
                                 		; multiply by 10
000131 e015                      		ldi tmp1, 5	; multiply by 5
000132 d005                      		rcall Cm_multiply
000133 8100                      		ld tmp, Z		; read remaining of number
000134 700f                      		andi tmp, 0b00001111	; converd BCD to bin
000135 0e70                      		add adc_sumL, tmp
000136 1c80                      		adc adc_sumH, z0
000137 9508                      		ret
                                 		
                                 ; Multiply tmp by (tmp1/2) and add it to adc_sumL:adc_sumH
                                 ; we supply half of tmp1 for speed purposes (we first multiply tmp by 2)
                                 Cm_multiply:		
000138 0f00                      		lsl tmp	; multiply by 2 
000139 0e70                      Cm_mul1:add adc_sumL, tmp
00013a 1c80                      		adc adc_sumH, z0
00013b 951a                      		dec tmp1
00013c f7e1                      		brne Cm_mul1
00013d 9508                      		ret
                                 
                                 		
                                 SA_Wait_Transfer_Compelted:
00013e 2700                      SA_L1:	clr tmp			; about 20-30ms
00013f 2711                      		clr tmp1
000140 9bb0                      SA_L2:	sbis PINB, CONF_PIN
000141 cffc                      		rjmp SA_L1				; start over, transmision is not finished
000142 951a                      		dec  tmp1
000143 f7e1                      		brne SA_L2
000144 950a                      		dec  tmp
000145 f7d1                      		brne SA_L2
000146 9508                      		ret
                                 
                                 ; tmp2 returns flag for start bit: 1-start bit, 0-timeout expired
                                 wait_for_start_short:
000147 2c31                      		mov tmp2,z1		; flag for start bit
000148 2700                      		clr tmp			; about 20-30ms
000149 2711                      		clr tmp1
00014a 9bb0                      wfs_L2:	sbis PINB, CONF_PIN
00014b c005                      		rjmp wfs_exit				; transmission started
00014c 951a                      		dec  tmp1
00014d f7e1                      		brne wfs_L2
00014e 950a                      		dec  tmp
00014f f7d1                      		brne wfs_L2
000150 2433                      		clr tmp2		; clear flag for start bit, because start bit did not came
                                 wfs_exit:
000151 9508                      		ret
                                 
                                 EnableTVout4sec:
000152 2466                      		clr adc_cntr
000153 9478                      		sei							; Enable TVout
000154 1460                      wt4s:	cp adc_cntr, z0
000155 f3f1                      		breq wt4s
000156 94f8                      		cli							; Disable TVout
                                 .include "eeprom.inc"
000157 9508                      
                                  * eeprom.inc
                                  *
                                  *  Created: 07-Jun-17 
                                  *   Author: Pavel
                                  */ 
000158 00c8                      Factory_data:	.DW FIRST_PRINT_TV_LINE			; TV Line to print 
000159 001e                      				.DB FIRST_PRINT_TV_COLUMN, 0		; TV Col to print and voltage offset
                                 
                                 ; tmp is value
                                 ; tmp1 is address
                                 EEPROM_read:
                                 		; Wait for completion of any previous operations
00015a 99e1                      		sbic EECR, EEPE
00015b cffe                      		rjmp EEPROM_read
00015c bb1e                      		out EEARL, tmp1
                                 		; Start eeprom read
00015d 9ae0                      		sbi EECR, EERE
                                 		; Read data from
00015e b30d                      		in tmp, EEDR
00015f 9508                      		ret
                                 
                                 EEPROM_write:
                                 		; Wait for completion of any previous operations
000160 99e1                      		sbic EECR, EEPE
000161 cffe                      		rjmp EEPROM_write 
                                 		; Set Programming mode
000162 ba0c                      		out EECR, z0
000163 bb1e                      		out EEARL, tmp1	; address
000164 bb0d                      		out EEDR, tmp	; data
                                 		; Write logical one to EEMPE
000165 9ae2                      		sbi EECR, EEMPE
                                 		; Start eeprom write by setting EEPE
000166 9ae1                      		sbi EECR, EEPE
000167 9508                      		ret
                                 		
                                 ; reset EEPROM to factory settings. After resetting MCU reset (via Watchdog) should be issued.
                                 ; before running this routine, ensure that interrupts are disabled
                                 EE_Reset_factory:
000168 ebe0                      		ldi ZL, low(Factory_data << 1)
000169 e0f2                      		ldi ZH, high(Factory_data << 1)
00016a e015                      		ldi tmp1, EEPROM_Start		; address in EEPROM
                                 EE_RstL1:
00016b 9105                      		lpm tmp, Z+
00016c dff3                      		rcall EEPROM_write
00016d 9513                      		inc tmp1
00016e 3019                      		cpi tmp1, EEPROM_Start+4 	; 4 bytes to restore
00016f f7d9                      		brne EE_RstL1
                                 .include "watchdog.inc"
000170 9508                      
                                 ; ensure, that Interrupts are disabled before calling one of the routines here
                                 WDT_Start_4s:	; with interrupt behaviour
000171 e610                      		ldi   tmp1, (0<<WDE) | (1<<WDTIE) | (1<<WDP3) | (0<<WDP2) | (0<<WDP1) | (0<<WDP0)		; 4s
000172 c001                      		rjmp WDT_Start_code
                                 WDT_Start_16ms:	; with reset bwhaviour
000173 e018                      		ldi   tmp1, (1<<WDE) | (0<<WDTIE) | (0<<WDP3) | (0<<WDP2) | (0<<WDP1) | (0<<WDP0)		; 16ms
                                 WDT_Start_code:
000174 95a8                      		wdr		; Reset Watchdog Timer
                                 		; Start timed sequence
000175 b501                      		in    tmp, WDTCR
000176 6108                      		ori   tmp, (1<<WDCE) | (1<<WDE)
000177 bd01                      		out   WDTCR, tmp
                                 		; --  Got four cycles to set the new values from here -
000178 bd11                      		out   WDTCR, tmp1
000179 9508                      		ret
                                 		
                                 WDT_off:
00017a 95a8                      		wdr		; Reset Watchdog Timer
                                 		; Clear WDRF in MCUSR
00017b b704                      		in    tmp, MCUSR
00017c 7f07                      		andi  tmp, (0xff - (1<<WDRF))
00017d bf04                      		out   MCUSR, tmp
                                 		; Write logical one to WDCE and WDE
                                 		; Keep old prescaler setting to prevent unintentional time-out
00017e b501                      		in    tmp, WDTCR
00017f 6108                      		ori   tmp, (1<<WDCE) | (1<<WDE)
000180 bd01                      		out   WDTCR, tmp
                                 		; Turn off WDT
000181 bc01                      		out   WDTCR, z0
000182 9508                      		ret
                                 		
                                 ;Watchdog interrupt routine here
                                 WATCHDOG:
000183 b62f                      		in r_sreg, SREG
000184 2c61                      		mov adc_cntr,z1		; just update adc variable, because WDT only enabled in Command mode, so, no ADC readings occur
000185 be2f                      		out SREG, r_sreg	
000186 9518                      		reti
                                 
                                 RESET:
                                 		; change speed (ensure 9.6 mhz ossc)
                                 
000187 e90f                      		ldi tmp, low(RAMEND); Main program start
000188 bf0d                      		out SPL,tmp ; Set Stack Pointer to top of RAM
                                 		
                                 		;init variables
000189 2400                      		clr z0
00018a 2411                      		clr z1
00018b 9413                      		inc z1
00018c 2466                      		clr adc_cntr		; couter for ADC readings (starting from 0)
00018d 2455                      		clr sym_line_nr		; first line of the char
00018e e052                      		ldi sym_H_cntr, SYMBOL_STRETCH	; init variable just in case
                                 
00018f e800                      		ldi tmp, 1<<CLKPCE	
000190 bd06                      		out CLKPR, tmp		; enable clock change
000191 bc06                      		out CLKPR, z0		; prescaler 1
                                 
000192 dfe7                      		rcall WDT_off		; just in case it left on after software reset
                                 		
                                 		; Configure Video pin as OUTPUT (LOW)
000193 9abc                      		sbi	DDRB, VIDEO_PIN
                                 		; Enable pullup on Configure Pin. We will enter configure mode if this pin will go LOW (by PCINT interrupt)
000194 9ac0                      		sbi	PORTB, CONF_PIN
                                 		
                                 		; set line from where to start printing (later we store this value in EEPROM)
000195 ec08                      		ldi tmp, low(FIRST_PRINT_TV_LINE)
000196 e010                      		ldi tmp1, high(FIRST_PRINT_TV_LINE)
000197 9300 0068                 		sts TV_line_start, tmp
000199 9310 0069                 		sts TV_line_start+1, tmp1
00019b e10e                      		ldi tmp, low(FIRST_PRINT_TV_COLUMN)
00019c 9300 006a                 		sts TV_col_start, tmp
                                 
                                 		;initialize INT0 
                                 		; INT0 - VIDEO Sync
00019e e003                      		ldi tmp, 1<<ISC01 | 1<<ISC00	; falling edge
00019f bf05                      		out MCUCR, tmp
0001a0 e400                      		ldi tmp, 1<<INT0 
0001a1 bf0b                      		out GIMSK, tmp
                                 				
                                 		; Configure ADC
                                 		; Internal 1.1Vref, ADC channel, 10bit ADC result
0001a2 e403                      		ldi tmp, 1<<REFS0 | 1<<MUX0 | 1<<MUX1
0001a3 b907                      		out ADMUX, tmp
                                 		; normal mode (single conversion mode), 64 prescaler (about 150khz at 9.6mhz ossc).
0001a4 ec06                      		ldi tmp, 1<<ADEN | 1<<ADSC | 1<<ADPS2 | 1<<ADPS1 | 0<<ADPS0
0001a5 b906                      		out ADCSRA, tmp
                                 		; turn off digital circuity in analog pin
0001a6 e008                      		ldi tmp, 1<<VBAT_PIN
0001a7 bb04                      		out DIDR0, tmp
                                 		
0001a8 e74e                      		ldi voltage, 126	; for debug
                                 
0001a9 9478                      		sei ; Enable interrupts
                                 
                                 main_loop:
                                 		; in the main loop we can run only not timing critical code like ADC reading
                                 
                                 		; read ADSC bit to see if conversion finished
                                 		;sbis ADCSRA, ADSC
                                 		;rcall ReadVoltage
                                 		
                                 		; Do we need to enter Configure mode?
0001aa 9bb0                      		sbis PINB, CONF_PIN
0001ab df3c                      		rcall EnterCommandMode
                                 		
0001ac cffd                      		rjmp main_loop				
                                 		
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny13A" register use summary:
x  :   1 y  :   1 z  :  15 r0 :  11 r1 :   4 r2 :   4 r3 :   9 r4 :  22 
r5 :   4 r6 :   7 r7 :  11 r8 :   8 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16:  69 r17:  25 r18:  16 r19:  10 r20:   3 
r21:   4 r22:   0 r23:   0 r24:   4 r25:   4 r26:   5 r27:   8 r28:   1 
r29:   1 r30:   7 r31:   6 
Registers used: 26 out of 35 (74.3%)

"ATtiny13A" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   3 add   :   4 adiw  :   2 and   :   0 
andi  :   4 asr   :   0 bclr  :   0 bld   :   6 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :  10 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   5 brlt  :   0 brmi  :   0 
brne  :  17 brpl  :   0 brsh  :   1 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   5 cbi   :   0 cbr   :   0 clc   :   1 
clh   :   0 cli   :   2 cln   :   0 clr   :  26 cls   :   0 clt   :   1 
clv   :   0 clz   :   0 com   :   0 cp    :   9 cpc   :   3 cpi   :   9 
cpse  :   0 dec   :  15 eor   :   0 icall :   0 ijmp  :   0 in    :   8 
inc   :   7 ld    :   8 ldd   :   0 ldi   :  41 lds   :   3 lpm   :   3 
lsl   :   1 lsr   :   2 mov   :   6 movw  :   0 neg   :   0 nop   :   0 
or    :   0 ori   :   2 out   :  25 pop   :   1 push  :   1 rcall :  30 
ret   :  17 reti  :   9 rjmp  :  19 rol   :   0 ror   :   2 sbc   :   1 
sbci  :   0 sbi   :   7 sbic  :   3 sbis  :   4 sbiw  :   0 sbr   :   0 
sbrc  :   0 sbrs  :   0 sec   :   1 seh   :   0 sei   :   3 sen   :   0 
ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 sleep :   0 
spm   :   0 st    :   7 std   :   0 sts   :   7 sub   :   2 subi  :   1 
swap  :   0 tst   :   0 wdr   :   2 
Instructions used: 47 out of 105 (44.8%)

"ATtiny13A" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00035a    710    148    858    1024  83.8%
[.dseg] 0x000060 0x00006c      0     12     12      64  18.8%
[.eseg] 0x000005 0x000009      0      4      4      64   6.3%

Assembly complete, 0 errors, 0 warnings
